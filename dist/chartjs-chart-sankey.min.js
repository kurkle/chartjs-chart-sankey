/*!
 * chartjs-chart-sankey v0.14.0
 * https://github.com/kurkle/chartjs-chart-sankey#readme
 * (c) 2025 Jukka Kurkela
 * Released under the MIT license
 */
!function(t,o){"object"==typeof exports&&"undefined"!=typeof module?o(require("chart.js"),require("chart.js/helpers")):"function"==typeof define&&define.amd?define(["chart.js","chart.js/helpers"],o):o((t="undefined"!=typeof globalThis?globalThis:t||self).Chart,t.Chart.helpers)}(this,(function(t,o){"use strict";const e=t=>void 0!==t;function r(t){return t&&-1!==["min","max"].indexOf(t)?t:"max"}const n=(t,o)=>o.flow===t.flow?t.index-o.index:o.flow-t.flow;function i(t,{size:o,priority:e,column:i}){const s=new Map;for(let o=0;o<t.length;o++){const{from:e,to:r,flow:n}=t[o],i=s.get(e)??{key:e,in:0,out:0,size:0,from:[],to:[]},a=(e===r?i:s.get(r))??{key:r,in:0,out:0,size:0,from:[],to:[]};i.out+=n,i.to.push({key:r,flow:n,index:o,node:a,addY:0}),1===i.to.length&&s.set(e,i),a.in+=n,a.from.push({key:e,flow:n,index:o,node:i,addY:0}),1===a.from.length&&s.set(r,a)}return((t,o)=>{const e=r(o);for(const o of t.values())o.from.sort(n),o.to.sort(n),o.size=Math[e](o.in||o.out,o.out||o.in)})(s,o),((t,o)=>{if(o)for(const e of t.values())e.key in o&&(e.priority=o[e.key])})(s,e),((t,o)=>{if(o)for(const e of t.values())e.key in o&&(e.column=!0,e.x=o[e.key])})(s,i),s}const s=1e-6,a=(t,o=new Set)=>{const e=[];for(const r of t)o.has(r.key)||(o.add(r.key),e.push(r.key,...a(r.to.map((t=>t.node)),o)));return e},l=(t,o)=>{const e=o.filter((t=>0===t.from.length)),r=e.map((t=>t.key)),n=a(e),i=new Set(n);for(const o of t)i.has(o.from)||i.has(o.to)||(r.push(o.from),i.add(o.from)),i.add(o.to);return r},c=(t,o)=>{const e=new Set(t.filter((t=>o.has(t.from))).map((t=>t.to))),r=[...o],n=r.filter((t=>!e.has(t)));return n.length?n:r.slice(0,1)};let h=-1;function f(t,o,e=function(){return h=h<100?h+1:0,h}()){let r=0;for(const n of t)n.node._visited!==e&&(n.node._visited=e,r+=n.node[o].length+f(n.node[o],o,e));return r}const d=t=>(o,e)=>f(o.node[t],t)-f(e.node[t],t)||o.node[t].length-e.node[t].length;function u(t,o){if(!t.from.length)return o;t.from.sort(d("from"));for(const r of t.from){const t=r.node;e(t.y)||(t.y=o,u(t,o?o+s:0)),o=Math.max(t.y+t.out,o)}return t.y+t.size}function y(t,o){if(!t.to.length)return o;t.to.sort(d("to"));for(const r of t.to){const t=r.node;e(t.y)||(t.y=o,y(t,o?o+s:0)),o=Math.max(t.y+Math.max(t.in,t.out),o)}return t.y+t.size}function p(t,o){return e(t.y)?t.y:(t.y=o,o)}function x(t,o){if(!t.length)return 0;const r=((t,o)=>{const e=[...t].sort(((t,o)=>t.size-o.size)).pop().size,r=t.filter((t=>t.size===e));return 1===r.length?r[0]:(r.sort(((t,o)=>t.x-o.x)),0===r[0].x?r[0]:r[r.length-1].x===o?r.pop():r[Math.floor(r.length/2)])})(t,o);return r.y=0,u(r,0),y(r,0),function(t,o){const r=t.filter((t=>0===t.x)),n=t.filter((t=>t.x===o)),i=r.filter((t=>!e(t.y))),a=n.filter((t=>!e(t.y))),l=t.filter((t=>t.x>0&&t.x<o&&!e(t.y)));let c=r.reduce(((t,o)=>Math.max(t,o.y+o.out||0)),0)+s,h=n.reduce(((t,o)=>Math.max(t,o.y+o.in||0)),0)+s,f=0;c>=h?(i.forEach((t=>{c=p(t,c),c=Math.max(c+t.out,y(t,c))})),a.forEach((t=>{h=p(t,h),h=Math.max(h+t.in,u(t,h))}))):(i.forEach((t=>{c=p(t,c)})),a.forEach((t=>{h=p(t,h),h=Math.max(h+t.in,u(t,h))}))),l.forEach((o=>{let r=t.filter((t=>t.x===o.x&&e(t.y))).reduce(((t,o)=>Math.max(t,o.y+Math.max(o.in,o.out))),0);r=p(o,r),r=Math.max(r+o.in,u(o,r)),r=Math.max(r+o.out,y(o,r)),f=Math.max(f,r)})),Math.max(c,h,f)}(t,o),((t,o)=>{let e=0;for(let r=0;r<=o;r++){const o=t.filter((t=>t.x===r)).sort(((t,o)=>t.y-o.y));let n=0;for(const t of o)t.y<n&&(t.y=n),n=t.y+t.size;e=Math.max(e,n)}return e})(t,o)}const m=(t,o)=>t.x!==o.x?t.x-o.x:t.y===o.y?t.size-o.size:t.y-o.y;function g(t,o,{priority:r,height:n,nodePadding:i,modeX:s,nodeVerticalPadding:a}){const h=[...t.values()],f=function(t,o,r){const n=o.filter((t=>t.from!==t.to)),i=[...t.keys()],s=[...t.values()],a=new Set(i);let h=0;for(;a.size;){const r=0===h?l(o,s):c(n,a);if(!r.length)throw new Error("Fatal error: Unable to place nodes to columns. Please report this issue.");for(const o of r){const r=t.get(o);r&&!e(r.x)&&(r.x=h),a.delete(o)}a.size&&h++}const f=s.reduce(((t,o)=>Math.max(t,o.x)),0);if("edge"===r){const e=new Set(o.map((t=>t.from)));i.filter((t=>!e.has(t))).forEach((o=>{const e=t.get(o);e&&!e.column&&(e.x=f)}))}return f}(t,o,s),d=r?function(t,o){let e=0,r=0;for(let n=0;n<=o;n++){let o=r;const i=t.filter((t=>t.x===n)).sort(((t,o)=>(t.priority??0)-(o.priority??0)));r=i.length&&i[0].to.filter((t=>t.node.x>n+1)).reduce(((t,o)=>t+o.flow),0)||0;for(const t of i)t.y=o,o+=Math.max(t.out,t.in);e=Math.max(o,e)}return e}(h,f):x(h,f),u=function(t,o,e){let r=0;const n=new Map,i=[];t.sort(m);for(const a of t){const t=(s=a.x,n.has(s)||(n.set(s,i.length),i.push([])),n.get(s)),l=i[t];if(a.y){l.push(a.y);let n=l.length;if(a.in){for(let o=0;o<t;o++){const t=i[o];for(let o=0;o<t.length&&!(t[o]>a.y);o++)n=Math.max(o+1,n)}for(;l.length<n;)l.push(a.y)}const s=e?.[a.key]||{top:0,bottom:0};a.y+=n*o+s.top,r=Math.max(r,a.y+Math.max(a.in,a.out)+s.bottom)}}var s;return r}(h,d/n*i,a);return function(t){t.forEach((t=>{const o=t.size,e=o<t.in,r=o<t.out;let n=0,i=t.from.length;t.from.sort(((t,o)=>t.node.y+t.node.out/2-(o.node.y+o.node.out/2))).forEach(((t,r)=>{e?t.addY=r*(o-t.flow)/(i-1):(t.addY=n,n+=t.flow)})),n=0,i=t.to.length,t.to.sort(((t,o)=>t.node.y+t.node.in/2-(o.node.y+o.node.in/2))).forEach(((t,e)=>{r?t.addY=e*(o-t.flow)/(i-1):(t.addY=n,n+=t.flow)}))}))}(h),{maxX:f,maxY:u}}function M(t,o,e){for(const r of t)if(r.key===o&&r.index===e)return r.addY;return 0}class w extends t.DatasetController{parseObjectData(t,o,e,r){const n=((t,o)=>{const{from:e="from",to:r="to",flow:n="flow"}=o;return t.map((({[e]:t,[r]:o,[n]:i})=>({from:t,to:o,flow:i})))})(o,this.options.parsing),{xScale:s,yScale:a}=t,l=[],c=this._nodes=i(n,this.options),{maxX:h,maxY:f}=g(c,n,{priority:!!this.options.priority,height:this.chart.canvas.height,nodePadding:this.options.nodePadding,modeX:this.options.modeX,nodeVerticalPadding:this.options.nodeVerticalPadding});if(this._maxX=h,this._maxY=f,!s||!a)return[];for(let t=0,o=n.length;t<o;++t){const o=n[t],e=c.get(o.from),r=c.get(o.to);if(!e||!r)continue;const i=(e.y??0)+M(e.to,o.to,t),h=(r.y??0)+M(r.from,o.from,t);l.push({x:s.parse(e.x,t),y:a.parse(i,t),_custom:{from:e,to:r,x:s.parse(r.x,t),y:a.parse(h,t),height:a.parse(o.flow,t),flow:o.flow}})}return l.slice(e,e+r)}getMinMax(t){return{min:0,max:t===this._cachedMeta.xScale?this._maxX:this._maxY}}update(t){const{data:o}=this._cachedMeta;this.updateElements(o,0,o.length,t)}updateElements(t,o,e,r){const{xScale:n,yScale:i}=this._cachedMeta;if(!n||!i)return;const s=this.resolveDataElementOptions(o,r),a=this.getSharedOptions(s),{borderWidth:l,nodeWidth:c=10}=this.options,h=l?l/2+.5:0;for(let s=o;s<o+e;s++){const o=this.getParsed(s),e=o._custom,a=i.getPixelForValue(o.y);this.updateElement(t[s],s,{x:n.getPixelForValue(o.x)+c+h,y:a,x2:n.getPixelForValue(e.x)-h,y2:i.getPixelForValue(e.y),from:e.from,to:e.to,progress:"reset"===r?0:1,height:Math.abs(i.getPixelForValue(o.y+e.height)-a),options:this.resolveDataElementOptions(s,r)},r)}this.updateSharedOptions(a,r,s)}_drawLabels(){const t=this.chart.ctx,o=this.options,e=this._nodes||new Map,n=r(o.size),i=o.borderWidth??1,s=o.nodeWidth??10,a=o.labels,{xScale:l,yScale:c}=this._cachedMeta;if(!l||!c)return;t.save();const h=this.chart.chartArea;for(const r of e.values()){const e=l.getPixelForValue(r.x),f=c.getPixelForValue(r.y),d=Math[n](r.in||r.out,r.out||r.in),u=Math.abs(c.getPixelForValue(r.y+d)-f),y=a?.[r.key]??r.key;let p=e;t.fillStyle=o.color??"black",t.textBaseline="middle",e<h.width/2?(t.textAlign="left",p+=s+i+4):(t.textAlign="right",p-=i+4),this._drawLabel(y,f,u,t,p)}t.restore()}_drawLabel(t,e,r,n,i){const s=o.toFont(this.options.font,this.chart.options.font),a=function(t){if(!t)return[];const o=[],e=Array.isArray(t)?t:[t];for(;e.length;){const t=e.pop();"string"==typeof t?o.unshift(...t.split("\n")):Array.isArray(t)?e.push(...t):t&&o.unshift(`${t}`)}return o}(t),l=a.length,c=e+r/2,h=s.lineHeight,f=o.valueOrDefault(this.options.padding,h/2);if(n.font=s.string,l>1){const t=c-h*l/2+f;for(let o=0;o<l;o++)n.fillText(a[o],i,t+o*h)}else n.fillText(t,i,c)}_drawNodes(){const t=this.chart.ctx,o=this._nodes||new Map,{borderColor:e,borderWidth:n=0,nodeWidth:i=10,size:s}=this.options,a=r(s),{xScale:l,yScale:c}=this._cachedMeta;t.save(),e&&n&&(t.strokeStyle=e,t.lineWidth=n);for(const e of o.values()){t.fillStyle=e.color??"black";const o=l.getPixelForValue(e.x),r=c.getPixelForValue(e.y),s=Math[a](e.in||e.out,e.out||e.in),h=Math.abs(c.getPixelForValue(e.y+s)-r);n&&t.strokeRect(o,r,i,h),t.fillRect(o,r,i,h)}t.restore()}draw(){const t=this.chart.ctx,o=this.getMeta().data??[],e=[];for(let t=0,r=o.length;t<r;++t){const r=o[t];r.from.color=r.options.colorFrom,r.to.color=r.options.colorTo,r.active&&e.push(r)}for(const t of e)t.from.color=t.options.colorFrom,t.to.color=t.options.colorTo;this._drawNodes();for(let e=0,r=o.length;e<r;++e)o[e].draw(t);this._drawLabels()}}w.id="sankey",w.defaults={dataElementType:"flow",animations:{numbers:{type:"number",properties:["x","y","x2","y2","height"]},progress:{easing:"linear",duration:t=>"data"===t.type?200*(t.parsed._custom.x-t.parsed.x):void 0,delay:t=>"data"===t.type?500*t.parsed.x+20*t.dataIndex:void 0},colors:{type:"color",properties:["colorFrom","colorTo"]}},color:"black",borderColor:"black",borderWidth:1,modeX:"edge",nodeWidth:10,nodePadding:10,transitions:{hide:{animations:{colors:{type:"color",properties:["colorFrom","colorTo"],to:"transparent"}}},show:{animations:{colors:{type:"color",properties:["colorFrom","colorTo"],from:"transparent"}}}}},w.overrides={interaction:{mode:"nearest",intersect:!0},datasets:{clip:!1,parsing:{from:"from",to:"to",flow:"flow"}},plugins:{tooltip:{callbacks:{title:()=>"",label(t){const o=t.parsed._custom;return o.from.key+" -> "+o.to.key+": "+o.flow}}},legend:{display:!1}},scales:{x:{type:"linear",bounds:"data",display:!1,min:0,offset:!1},y:{type:"linear",bounds:"data",display:!1,min:0,reverse:!0,offset:!1}},layout:{padding:{top:3,left:3,right:13,bottom:3}}};const b=(t,o,e,r)=>t<e?{cp1:{x:t+(e-t)/3*2,y:o},cp2:{x:t+(e-t)/3,y:r}}:{cp1:{x:t-(t-e)/3,y:0},cp2:{x:e+(t-e)/3,y:0}},k=(t,o,e)=>({x:t.x+e*(o.x-t.x),y:t.y+e*(o.y-t.y)}),v=(t,e)=>o.color(t).alpha(e).rgbString(),P=(t,o)=>"string"==typeof t?v(t,o):t;class _ extends t.Element{draw(t){const{x:o,x2:e,y:r,y2:n,height:i,progress:s}=this,{cp1:a,cp2:l}=b(o,r,e,n);0!==s&&(t.save(),s<1&&(t.beginPath(),t.rect(o,Math.min(r,n),(e-o)*s+1,Math.abs(n-r)+i+1),t.clip()),function(t,{x:o,x2:e,options:r}){let n="black";"from"===r.colorMode?n=P(r.colorFrom,r.alpha):"to"===r.colorMode?n=P(r.colorTo,r.alpha):"string"==typeof r.colorFrom&&"string"==typeof r.colorTo&&(n=t.createLinearGradient(o,0,e,0),n.addColorStop(0,v(r.colorFrom,r.alpha)),n.addColorStop(1,v(r.colorTo,r.alpha))),t.fillStyle=n,t.strokeStyle=n,t.lineWidth=.5}(t,this),t.beginPath(),t.moveTo(o,r),t.bezierCurveTo(a.x,a.y,l.x,l.y,e,n),t.lineTo(e,n+i),t.bezierCurveTo(l.x,l.y+i,a.x,a.y+i,o,r+i),t.lineTo(o,r),t.stroke(),t.closePath(),t.fill(),t.restore())}inRange(t,o,e){const{x:r,y:n,x2:i,y2:s,height:a}=this.getProps(["x","y","x2","y2","height"],e);if(t<r||t>i)return!1;const{cp1:l,cp2:c}=b(r,n,i,s),h=(t-r)/(i-r),f={x:i,y:s},d=k({x:r,y:n},l,h),u=k(l,c,h),y=k(c,f,h),p=k(d,u,h),x=k(u,y,h),m=k(p,x,h).y;return o>=m&&o<=m+a}inXRange(t,o){const{x:e,x2:r}=this.getProps(["x","x2"],o);return t>=e&&t<=r}inYRange(t,o){const{y:e,y2:r,height:n}=this.getProps(["y","y2","height"],o),i=Math.min(e,r),s=Math.max(e,r)+n;return t>=i&&t<=s}getCenterPoint(t){const{x:o,y:e,x2:r,y2:n,height:i}=this.getProps(["x","y","x2","y2","height"],t);return{x:(o+r)/2,y:(e+n+i)/2}}tooltipPosition(t){return this.getCenterPoint(t)}getRange(t){return"x"===t?this.width/2:this.height/2}constructor(t){super(),t&&Object.assign(this,t)}}_.id="flow",_.defaults={colorFrom:"red",colorTo:"green",colorMode:"gradient",alpha:.5,hoverColorFrom:(t,e)=>o.getHoverColor(e.colorFrom),hoverColorTo:(t,e)=>o.getHoverColor(e.colorTo)},_.descriptors={_scriptable:!0},t.Chart.register(w,_)}));
